{"title":"Twitch API Authentication","slug":"twitch-api","html":"<p>前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容</p>\n<summary>\n\n<h2 id=\"官方文章：理解哪種協議與流程適合你\">官方文章：<a target=\"_blank\" rel=\"nofollow\" href=\"https://blog.twitch.tv/zh-tw/2019/11/06/twitch-authentication-understanding-which-protocol-and-flow-is-right-for-you/\">理解哪種協議與流程適合你</a></h2>\n</summary>\n<details>\n\n<p>在首次使用 Twitch 開發新的整合或擴充套件時，最常見的障礙之一是確定最適合您需求的驗證方法。這個決定可能會讓人感到困惑，特別是當你是對 REST API 進行身份驗證的新手時，但本指南將涵蓋如何就協議、必要的令牌型別以及使用協議的適當方式做出明智的決定。</p>\n<p>Twitch 提供了兩種協議，即 OAuth 和 OIDC，以使用您選擇的流來連線和獲取令牌。流量 &quot;只是指您的應用程式與 Twitch 進行互動以交換令牌的方式，以及返回令牌的方式。</p>\n<p>此外，在選擇兩種協議的同時，您還需要圍繞您所需的令牌型別做出重要決定；有三種不同的令牌可供選擇，每種令牌都有不同的用途。</p>\n<p>這些決定可能會根據一些因素而變化，例如正在構建的整合型別，您的應用程式如何架構，以及您使用認證協議的經驗水平。</p>\n<p>簡而言之，有一個簡單的圖表，顯示了不同型別的令牌和基礎設施，以幫助您的決策過程。請注意，這並不是確定的，您的情況可能會有所不同，您應該選擇最適合您需求的選項。</p>\n<h3 id=\"協議\">協議</h3>\n<p>如前所述，在應用中認證使用者時有兩種協議可供選擇 --OAuth 2.0 和 OIDC。這兩個協議在功能上非常相似，因為 OIDC 是建立在 OAuth 2.0 規範之上的，但也有理由選擇一個而不是另一個。</p>\n<h4 id=\"oauth-20\">OAuth 2.0</h4>\n<p>我們要介紹的第一個協議是 OAuth 2.0（以下簡稱 OAuth），它是使用 Twitch 平臺授權的最常見方式之一。OAuth 在許多組織中被廣泛採用，它本身就傾向於為幾乎所有的程式語言提供大量可供公眾使用的庫，這意味著在你的應用程式中構建授權是快速和簡單的，只需要很少的定製工作。OAuth 可以提供使用者訪問令牌（user access token）或應用程式訪問令牌（app access token）。使用者訪問令牌（user access token，通常稱為&quot; 訪問令牌 &quot;／access token）允許您的應用程式代表經過認證的使用者在給定的一組範圍（許可權）內執行操作。另一方面，應用程式訪問令牌（App access tokens）僅用於伺服器對伺服器的呼叫，不提供對一些受保護的 API 端點的訪問。</p>\n<p>使用者訪問令牌和應用訪問令牌用於針對 Twitch 的 API 進行認證呼叫。</p>\n<p>然而，OAuth 的一個主要問題是，它不是一個認證協議。OAuth 本身並不告訴使用者是誰，而是提供了一組委託許可權，允許透過提供的訪問令牌訪問受保護的資源。這授權令牌訪問材料，但並不對使用者進行身份驗證。</p>\n<p>你可以透過 Twitch API 的 Get User 端點來獲取授權 token 的使用者的詳細資訊，但是僅僅為了獲取使用者身份而呼叫這個端點是對 OAuth 的濫用，因為它只會告訴你 token 的所有者，但不會告訴你他們已經認證進入你的應用。</p>\n<p>這裡的區別主要涉及安全原則。令牌不是使用者認證的證明，就像前門鑰匙不是房屋所有權的證明一樣。令牌只能證明使用者已經授權您的應用程式代表他們行事，這也是我們建議使用下面描述的第二個協議的主要原因之一。</p>\n<h4 id=\"openid-連線\">OpenID 連線</h4>\n<p>OpenID Connect（OIDC）是建立在 OAuth 之上的，它將 OAuth 規範中的一些東西標準化，讓人們可以選擇。此外，OIDC 除了提供授權之外，還提供了認證。由於 OIDC 是在 OAuth 的基礎上分層的，所以如果你已經熟悉 OAuth，很多東西都是一樣的，因此很容易學習。</p>\n<p>與 OIDC 的主要區別之一是它可以返回一個 ID Token，這是一個 JSON Web Token (JWT)，其中包含了認證使用者的資訊。這個令牌可以透過索賠包含使用者的基本資訊，也可以包含使用者的詳細資訊。索賠可以包括（但不限於）使用者名稱、電子郵件和個人資料圖片。這些資訊無需額外的 API 呼叫即可獲得，並為這些資訊提供了快速資源。這可以驗證使用者的身份，以確保使用者是訪問材料的人。</p>\n<p>一個 JWT 的範例：</p>\n<p><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifQ.eyJhdWQiOiJhOGF2NHo3MGY1M2QyMnNwZXBlemJkaWx5Y29yaHQiLCJleHAiOjE1NTk2NzY2NDEsImlhdCI6MTU1OTY3NTc0MSwiaXNzIjoiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyIiwic3ViIjoiNDQ2MzU1OTYiLCJwaWN0dXJlIjoiaHR0cHM6Ly9zdGF0aWMtY2RuLmp0dm53Lm5ldC9qdHZfdXNlcl9waWN0dXJlcy8zNzVlZTZmZC04ZGNkLTQ3ZjEtOTNkYi04MTY2NzgyODhlMTMtcHJvZmlsZV9pbWFnZS0xNTB4MTUwLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IkNvbmNyZXRlRW50cmVlIn0.xz44-jsojGL188TkO5TqqEVusAnCEFWUXdkX5awV-0m5FFTHqEfZOTHxUMV3UCfmDGaz76g0kVm0NErYT4GRZjYmeahIYOWFQhQ0tdf31JGflrh3IXCjHAEnAcVHiHLQirrK9gC2zuqIbW3383lLmiFbakG1KdginYScWjUTHF3RPyeQsWjQI8iscRr_i9ogmRnHfq1bj3sS0DBQiJ1OTmUwBhXFXI9dWZGskvCXDAQ2m06ulB7lYgkl_yaqYaXOfnhcrvIrfcwSTqByPJP3bpUwFUsDpePhShFuogxEpzF1hWSXb1x819uldtF0PQfBhAtIs28f5DrSDUWNb5IChQ</code></p>\n<p>經過解碼（使用 <a target=\"_blank\" rel=\"nofollow\" href=\"https://jwt.io/\">https://jwt.io/</a>）後會變為</p>\n<pre class=\"language-json\"><code class=\"language-json\">{\n  \"aud\": \"a8av4z70f53d22spepezbdilycorht\",\n  \"exp\": 1559676641,\n  \"iat\": 1559675741,\n  \"iss\": \"https://id.twitch.tv/oauth2\",\n  \"sub\": \"44635596\",\n  \"picture\": \"https://static-cdn.jtvnw.net/jtv_user_pictures/375ee6fd-8dcd-47f1-93db-816678288e13-profile_image-150x150.png\",\n  \"preferred_username\": \"ConcreteEntree\"\n}</code></pre><p>這些資訊也可以用於展示目的，所以，例如，React 應用程式可以將 JWT 儲存在狀態中，並引用使用者名稱作為頁面頭部的一部分，而不是將其儲存在資料庫的某個地方，需要在登入時獲取；該資料也會隨著每次 token 的重新整理而更新，這意味著資料是最新的。</p>\n<p>需要注意的是，ID Token 並不是用來進行 API 請求的，它只是認證以及使用者身份的證明。</p>\n<p>OIDC 除了 ID Token 之外，還可以返回一個標準的使用者訪問令牌，既可以代表使用者行動，也可以知道使用者是誰。</p>\n<p>OIDC 的主要注意事項是，它不支援返回應用訪問令牌，這意味著對於伺服器到伺服器的通訊，OAuth 是你唯一的選擇。儘管如此，我們還是建議在所有其他情況下儘可能使用 OIDC。</p>\n<h3 id=\"流程\">流程</h3>\n<p>對於 OAuth 和 OIDC 來說，它們都支援兩種不同的流程，或者說是獲取令牌的方法。它們是授權碼（Authorization Code）流和隱式（Implicit Code）流。</p>\n<p>這兩種流程在幾個關鍵方面有所不同。授權程式碼應該用於有伺服器進行呼叫以獲取令牌並使用該令牌訪問受保護的 API 端點的情況。有額外的握手，提供必要的資訊，這意味著使用者永遠不會獲得他們的實際訪問令牌（除非你把它傳送到前端），使其更加安全。此外，這個流程還返回一個重新整理令牌，這意味著你的使用者在未來不必重新授權你的應用程式。這些重新整理令牌被你的應用程式用來給使用者一個新的訪問令牌，並有一個新的到期日期。</p>\n<p>隱式程式碼是在客戶端（使用者代理）將進行呼叫時使用的。這在使用 React 或 Vue 等框架的單頁應用（SPA）中最為常見。使用者進行身份驗證，瀏覽器在本地獲取並儲存令牌，以代表使用者進行額外的呼叫，或者說 SPA 沒有後端儲存使用者資料。雖然 SPA 架構涉及到一個儲存程式碼的 Web 服務，但這個服務永遠不會獲得使用者的訪問 token（除非客戶端將其傳送到後端）。這個流程不會返回重新整理令牌，所以你需要使用者在令牌過期時重新授權應用。</p>\n<p>最後，還有一個客戶端憑證流，它允許你獲取應用訪問令牌。這個流程只有透過 OAuth 協議才能使用，也是獲取應用訪問令牌的唯一途徑。如上所述，由於缺乏使用者原則，這些令牌無法使用訪問給定使用者受保護資料的端點（例如 GET /users 端點中的使用者電子郵件），並且僅用於伺服器到伺服器的呼叫。該流不返回重新整理令牌。</p>\n<h4 id=\"授權碼\">授權碼</h4>\n<p>如上所述，與其他流程相比，授權碼流程需要一些額外的呼叫，但是由於在授權過程中不需要向瀏覽器傳輸訪問令牌，因此最終的應用更加安全。</p>\n<p>授權碼的流程是</p>\n<ol>\n<li><p>你的應用程式將使用者重定向到 Twitch 登入端點</p>\n</li>\n<li><p>使用者登入並授權給應用程式所要求的作用域</p>\n</li>\n<li><p>一旦成功授權，Twitch 就會重定向回您的應用程式，並在查詢引數中包含一段程式碼。</p>\n</li>\n<li><p>然後，使用一個特殊的端點，用後端伺服器將程式碼交換為您所需的代幣。</p>\n</li>\n</ol>\n<p>這個過程可以讓你安全而謹慎地儲存代幣。雖然比隱式流程的步驟更多，但這是 Twitch 的首選方法。</p>\n<h4 id=\"隱性程式碼\">隱性程式碼</h4>\n<p>另一種面向使用者的流程是隱式流程。這種流專注於儘可能安全地傳輸訪問令牌，然而無論如何，訪問令牌都會暴露在終端使用者面前。正因為如此，隱式流不支援重新整理令牌，需要使用者每次重新認證才能獲得有效的使用者令牌。</p>\n<p>這種方式是透過：</p>\n<ol>\n<li><p>使用者會被重定向到 Twitch 登入（使用彈窗或瀏覽器重定向）。</p>\n</li>\n<li><p>然後，使用者授權應用程式</p>\n</li>\n<li><p>然後，使用者會被 Twitch 用 URL 片段中的令牌重定向到重定向 URI（由整合配置）。</p>\n</li>\n<li><p>該 URL 看起來像：<code>https://yoururlhere/index.html#access_token=token...</code></p>\n</li>\n</ol>\n<p>這種情況下的令牌不在請求查詢中，因為請求查詢會被傳送到後端伺服器（以及中間可能出現的任何其他伺服器）。相反，它使用的是 URL 片段，它對後端伺服器不可見，因此更加安全。URL 片段可以透過客戶端的 JavaScript 訪問，允許你從 URL 中提取出來，並儲存起來以備後用。</p>\n<h4 id=\"客戶證書\">客戶證書</h4>\n<p>最後，客戶端憑證流的目的是當你需要從伺服器到伺服器進行呼叫時。這個令牌不能新增任何額外的作用域，因為沒有一個使用者來繫結這個令牌；相反，這些令牌是為了不特定於任何使用者的後端任務。它可能是涉及應用級分析或需要更高速率限制的任務。</p>\n<p>正如圖中所指出的，這個流程只能使用 OAuth，而不是 OIDC。因此，在選擇這個流程時要記住這一點。</p>\n<p>流程相當簡單，後臺伺服器向 Twitch 發出請求，要求獲得一個令牌，並得到一個回報。響應格式與授權碼響應相同，因此您能夠以同樣的方式重新整理令牌。</p>\n<p>但與其他流程不同的是，由於這只生成一個應用訪問令牌，所以不能將其分配給使用者，因此您不能為這個令牌分配作用域。使用這種型別的令牌通常用於提高呼叫的速率限制，以確保你不會發出未經認證的請求。</p>\n<h3 id=\"總結\">總結</h3>\n<p>確定使用什麼技術讓使用者授權你的應用是你早期要做的一個相當重要的決定。由於可用的選項數量眾多，在剛開始專案時可能會讓人不知所措。然而，簡單地說，對於大多數用例，如果您可以使用 OIDC，您就應該這樣做。鑑於 OIDC 是建立在 OAuth 之上的，對於終端使用者來說，授權流程保持不變，你獲得了額外的功能，同時也保留了 OAuth 的所有易用性，而不需要更多的額外複雜性。</p>\n</details>\n\n<h2 id=\"twitch-oidc-認證響應\">Twitch OIDC 認證響應</h2>\n<ul>\n<li>Twitch API 文件：<a target=\"_blank\" rel=\"nofollow\" href=\"https://dev.twitch.tv/docs/authentication\">Authentication | Twitch Developers</a></li>\n<li>註冊 Twitch APP：<a target=\"_blank\" rel=\"nofollow\" href=\"https://dev.twitch.tv/console/apps\">Twitch Developers</a></li>\n<li><a target=\"_blank\" rel=\"nofollow\" href=\"https://pjchender.blogspot.com/2018/08/js-javascript-url-parameters.html\">[JS] 使用 JavaScript 解析網址與處理網址中的參數（URL Parameters） ~ PJCHENder&lt;br&gt;那些沒告訴你的小細節</a></li>\n</ul>\n<h3 id=\"驗證\">驗證</h3>\n<p><code>GET https://id.twitch.tv/oauth2/authorize ?client_id=&lt;your client ID&gt; &amp;redirect_uri=&lt;your registered redirect URI&gt; &amp;response_type=&lt;type&gt; &amp;scope=&lt;space-separated list of scopes&gt; &amp;claims=&lt;JSON object specifying requested claims&gt;</code></p>\n<h4 id=\"成功\">成功</h4>\n<p><code>&lt;path-to-page&gt;#access_token=&lt;access_token&gt;&amp;id_token=&lt;id_token&gt;&amp;scope=openid+user_read&amp;token_type=bearer</code></p>\n<ol>\n<li><code>access_token</code></li>\n<li><code>id_token</code></li>\n<li><code>scope</code></li>\n<li><code>token_type</code></li>\n</ol>\n<p><code>id_token</code> decoded:</p>\n<ol>\n<li><code>at_hash</code></li>\n<li><code>aud</code>: Audience: client ID of the application requesting a user&#39;s authorization.</li>\n<li><code>azp</code>: Authorized party: client ID of the application which is being authorized. Currently the same as aud.</li>\n<li><code>exp</code>: Expiration time of the token. This is in UNIX/Epoch format.</li>\n<li><code>iat</code>: Time when the token was issued. This is in UNIX/Epoch format.</li>\n<li><code>iss</code>: Issuer of the token.</li>\n<li><code>preferred_username</code>: Display name of the authorizing user.</li>\n<li><code>sub</code>: User ID of the authorizing user.</li>\n</ol>\n<h4 id=\"失敗\">失敗</h4>\n<p><code>&lt;path-to-page&gt;?error=redirect_mismatch&amp;error_description=Parameter+redirect_uri+does+not+match+registered+URI</code></p>\n<ol>\n<li><code>error</code></li>\n<li><code>error_description</code></li>\n</ol>\n<h3 id=\"取得使用者帳號\">取得使用者帳號</h3>\n<pre class=\"language-bash\"><code class=\"language-bash\">curl  -H 'Client-ID: uo6dggojyb8d6soh92zknwmi5ej1q2' \\\n-H 'Authorization: Bearer cfabdegwdoklmawdzdo98xt2fo512y' \\\n-X GET 'https://api.twitch.tv/helix/users?id=44322889'</code></pre>","date":"2020-11-08T23:50:09.000Z","excerpt":"前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容","printDate":"November 8, 2020","printReadingTime":"3 min read"}