<!DOCTYPE html> <html lang=zh-Hant-TW> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=https://fonts.googleapis.com rel=preconnect> <link href=https://fonts.gstatic.com rel=preconnect crossorigin> <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest> <link href=favicon.png rel=icon type=image/png> <link href=client/client-985601bd.css rel=stylesheet><link href=client/[slug]-7df1c62f.css rel=stylesheet> <title>Twitch API Authentication</title><script async data-svelte=svelte-a2kvt3 src="https://www.googletagmanager.com/gtag/js?id=UA-114661136-2"></script><script async data-svelte=svelte-1op50db src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js data-ad-client=ca-pub-9613661448556355></script><link href=/favicon.ico rel="shortcut icon" data-svelte=svelte-oksmvs><link href=/favicon.ico rel=bookmark data-svelte=svelte-oksmvs><link href=https://f6bfb5.github.io/twitch-api rel=canonical data-svelte=svelte-oowxqk><meta data-svelte=svelte-oowxqk content=https://f6bfb5.github.io/twitch-api property=og:url><meta data-svelte=svelte-oowxqk content=article property=og:type><meta data-svelte=svelte-oowxqk content="Twitch API Authentication" property=og:title><meta data-svelte=svelte-oowxqk content="前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容" property=og:description><meta data-svelte=svelte-oowxqk content="前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容" name=Description><meta data-svelte=svelte-oowxqk content=https://f6bfb5.github.io/preview/twitch-api.png property=og:image><meta data-svelte=svelte-oowxqk content=summary_large_image name=twitter:card><meta data-svelte=svelte-oowxqk name=twitter:title value="Twitch API Authentication"><meta data-svelte=svelte-oowxqk content="前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容" name=twitter:description><meta data-svelte=svelte-oowxqk name=twitter:label1 value="Published on"><meta data-svelte=svelte-oowxqk name=twitter:data1 value="Nov 8, 2020"> <link href=/client/client.fe24f1bc.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-985601bd.css rel=preload as=style><link href=/client/[slug].9021dd7e.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-7df1c62f.css rel=preload as=style></head> <body> <div id=sapper> <div class="svelte-5s6wka layout"> <header class=svelte-1f9e1m7><nav class=svelte-182lynk><a href=. class=svelte-182lynk>blog</a> <a href=about class=svelte-182lynk>about</a> <a href=rss.xml class=svelte-182lynk>rss</a> </nav> <a href=/ class=svelte-kw2jbs> <img alt=logo src=data:image/gif;base64,AAABAAEAEBAQAAAAAAAoAQAAFgAAACgAAAAQAAAAIAAAAAEABAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAABbl4Awr28AAAAAAC4pp4ACgUAAFomhAB4aGEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIiIiIiQiQiIkREREREJCIiQRERERESIiJBEhEREREiIkFCQRFRESIiQRIRERFRIiJBEREREREiIkE2ZmZmESQiQWYAAAZhJCJBZgAABmEkIkFmAAAGYSQiQWYAAAZhRCJBZgAABmFEIkE2ZmZmMUQiQRERERERRCJERERERERCLABwAAgAMAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAwAA style=width:36px;height:42px> </a> </header> <main class=svelte-5s6wka> <header class=svelte-qm931c> <h1 class="svelte-qm931c title"><span class=svelte-qm931c style=animation-delay:125ms>T</span><span class=svelte-qm931c style=animation-delay:150ms>w</span><span class=svelte-qm931c style=animation-delay:175ms>i</span><span class=svelte-qm931c style=animation-delay:.2s>t</span><span class=svelte-qm931c style=animation-delay:225ms>c</span><span class=svelte-qm931c style=animation-delay:250ms>h</span><span class=svelte-qm931c style=animation-delay:275ms;width:.25em> </span><span class=svelte-qm931c style=animation-delay:.3s>A</span><span class=svelte-qm931c style=animation-delay:325ms>P</span><span class=svelte-qm931c style=animation-delay:350ms>I</span><span class=svelte-qm931c style=animation-delay:375ms;width:.25em> </span><span class=svelte-qm931c style=animation-delay:.4s>A</span><span class=svelte-qm931c style=animation-delay:425ms>u</span><span class=svelte-qm931c style=animation-delay:450ms>t</span><span class=svelte-qm931c style=animation-delay:475ms>h</span><span class=svelte-qm931c style=animation-delay:.5s>e</span><span class=svelte-qm931c style=animation-delay:525ms>n</span><span class=svelte-qm931c style=animation-delay:550ms>t</span><span class=svelte-qm931c style=animation-delay:575ms>i</span><span class=svelte-qm931c style=animation-delay:.6s>c</span><span class=svelte-qm931c style=animation-delay:625ms>a</span><span class=svelte-qm931c style=animation-delay:650ms>t</span><span class=svelte-qm931c style=animation-delay:675ms>i</span><span class=svelte-qm931c style=animation-delay:.7s>o</span><span class=svelte-qm931c style=animation-delay:725ms>n</span></h1> <p class=svelte-qm931c>November 8, 2020 <small class=svelte-qm931c>4 min read</small></header> <div class="svelte-qm931c container"><article class=content><p>前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容</p> <summary> <h2 id=官方文章：理解哪種協議與流程適合你>官方文章：<a href=https://blog.twitch.tv/zh-tw/2019/11/06/twitch-authentication-understanding-which-protocol-and-flow-is-right-for-you/ target=_blank rel=nofollow>理解哪種協議與流程適合你</a></h2> </summary> <details> <p>在首次使用 Twitch 開發新的整合或擴充套件時，最常見的障礙之一是確定最適合您需求的驗證方法。這個決定可能會讓人感到困惑，特別是當你是對 REST API 進行身份驗證的新手時，但本指南將涵蓋如何就協議、必要的 token 型別以及使用協議的適當方式做出明智的決定。</p> <p>Twitch 提供了兩種協議，即 OAuth 和 OIDC，以使用您選擇的 flow 來連線和獲取 token 。flow 只是指您的應用程式與 Twitch 進行互動以交換 token 的方式，以及回傳 token 的方式。</p> <p>此外，在選擇兩種協議的同時，您還需要圍繞您所需的 token 型別做出重要決定；有三種不同的 token 可供選擇，每種 token 都有不同的用途。</p> <p>這些決定可能會根據一些因素而變化，例如正在構建的整合型別，您的應用程式如何架構，以及您使用認證協議的經驗水平。</p> <p>簡而言之，有一個簡單的圖表，顯示了不同型別的 token 和基礎設施，以幫助您的決策過程。請注意，這並不是絕對的，您的情況可能會有所不同，您應該選擇最適合您需求的選項。</p> <table> <thead> <tr> <th></th> <th>擁有後端</th> <th>沒有後端／SPA</th> <th>伺服器對伺服器（無前端）</th> </tr> </thead> <tr> <td>ID Token</td> <td>OIDC 授權碼</td> <td>OIDC 隱式碼</td> <td>-</td> </tr> <tr> <td>User Access Token</td> <td>OAuth／OIDC 授權碼</td> <td>OAuth／OIDC 隱式碼</td> <td>-</td> </tr> <tr> <td>App Access Token</td> <td>OAuth 客戶證書（於後端處理）</td> <td>-</td> <td>OAuth 客戶證書</td> </tr> </table> <h3 id=協議>協議</h3> <p>如前所述，在應用中認證使用者時有兩種協議可供選擇：OAuth 2.0 和 OIDC。這兩個協議在功能上非常相似，因為 OIDC 是建立在 OAuth 2.0 規範之上的，但也有理由選擇一個而不是另一個。</p> <h4 id=oauth-20>OAuth 2.0</h4> <p>我們要介紹的第一個協議是 OAuth 2.0（以下簡稱 OAuth），它是使用 Twitch 平臺授權的最常見方式之一。OAuth 在許多組織中被廣泛採用，它本身就傾向於為幾乎所有的程式語言提供大量可供公眾使用的庫，這意味著在你的應用程式中構建授權是快速和簡單的，只需要很少的定製工作。OAuth 可以提供「使用者存取 token」（User Access Token，通常簡稱為「存取 token」／access token）或「應用程式存取 token」（App Access Token）。「使用者存取 token」允許您的應用程式代表經過認證的使用者，在給定的一組範圍（許可權）內執行操作。另一方面，「應用程式存取 token」僅用於伺服器對伺服器的呼叫，不提供對一些受保護的 API 端點的存取。</p> <p>「使用者存取 token」和「應用存取 token」用於針對 Twitch 的 API 進行認證呼叫。</p> <p>然而，OAuth 的一個主要問題是，它不是一個認證協議。OAuth 本身並不告訴使用者是誰，而是提供了一組委託許可權，允許透過提供的存取 token 存取受保護的資源。這授權 token 存取材料，但並不對使用者進行身份驗證。</p> <p>你可以透過 Twitch API 的 Get User 端點來獲取授權 token 的使用者的詳細資訊，但是僅僅為了獲取使用者身份而呼叫這個端點是對 OAuth 的濫用，因為它只會告訴你 token 的所有者，但不會告訴你他們已經認證進入你的應用。</p> <p>這裡的區別主要涉及安全原則。 token 不是使用者認證的證明，就像前門鑰匙不是房屋所有權的證明一樣。 token 只能證明使用者已經授權您的應用程式代表他們行事，這也是我們建議使用下面描述的第二個協議的主要原因之一。</p> <h4 id=openid-連線>OpenID 連線</h4> <p>OpenID Connect（OIDC）是建立在 OAuth 之上的，它將 OAuth 規範中的一些東西標準化，讓人們可以選擇。此外，OIDC 除了提供授權之外，還提供了認證。由於 OIDC 是在 OAuth 的基礎上分層的，所以如果你已經熟悉 OAuth，很多東西都是一樣的，因此很容易學習。</p> <p>與 OIDC 的主要區別之一是它可以回傳一個「ID Token」，這是一個 JSON Web Token (JWT)，其中包含了認證使用者的資訊。這個 token 可以透過索賠包含使用者的基本資訊，也可以包含使用者的詳細資訊。索賠可以包括（但不限於）使用者名稱、電子郵件和個人資料圖片。這些資訊無需額外的 API 呼叫即可獲得，並為這些資訊提供了快速資源。這可以驗證使用者的身份，以確保使用者是存取材料的人。</p> <p>一個 JWT 的範例：</p> <p><code>eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifQ.eyJhdWQiOiJhOGF2NHo3MGY1M2QyMnNwZXBlemJkaWx5Y29yaHQiLCJleHAiOjE1NTk2NzY2NDEsImlhdCI6MTU1OTY3NTc0MSwiaXNzIjoiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyIiwic3ViIjoiNDQ2MzU1OTYiLCJwaWN0dXJlIjoiaHR0cHM6Ly9zdGF0aWMtY2RuLmp0dm53Lm5ldC9qdHZfdXNlcl9waWN0dXJlcy8zNzVlZTZmZC04ZGNkLTQ3ZjEtOTNkYi04MTY2NzgyODhlMTMtcHJvZmlsZV9pbWFnZS0xNTB4MTUwLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IkNvbmNyZXRlRW50cmVlIn0.xz44-jsojGL188TkO5TqqEVusAnCEFWUXdkX5awV-0m5FFTHqEfZOTHxUMV3UCfmDGaz76g0kVm0NErYT4GRZjYmeahIYOWFQhQ0tdf31JGflrh3IXCjHAEnAcVHiHLQirrK9gC2zuqIbW3383lLmiFbakG1KdginYScWjUTHF3RPyeQsWjQI8iscRr_i9ogmRnHfq1bj3sS0DBQiJ1OTmUwBhXFXI9dWZGskvCXDAQ2m06ulB7lYgkl_yaqYaXOfnhcrvIrfcwSTqByPJP3bpUwFUsDpePhShFuogxEpzF1hWSXb1x819uldtF0PQfBhAtIs28f5DrSDUWNb5IChQ</code></p> <p>經過解碼（使用 <a href=https://jwt.io/ target=_blank rel=nofollow>https://jwt.io/</a>）後會變為</p> <pre class=language-json><code class=language-json>{
  "aud": "a8av4z70f53d22spepezbdilycorht",
  "exp": 1559676641,
  "iat": 1559675741,
  "iss": "https://id.twitch.tv/oauth2",
  "sub": "44635596",
  "picture": "https://static-cdn.jtvnw.net/jtv_user_pictures/375ee6fd-8dcd-47f1-93db-816678288e13-profile_image-150x150.png",
  "preferred_username": "ConcreteEntree"
}</code></pre><p>這些資訊也可以用於展示目的，所以，例如，React 應用程式可以將 JWT 儲存在狀態中，並引用使用者名稱作為頁面頭部的一部分，而不是將其儲存在資料庫的某個地方，需要在登入時獲取；該資料也會隨著每次 token 的重新整理而更新，這意味著資料是最新的。</p> <p>需要注意的是，ID Token 並不是用來進行 API 請求的，它只是認證以及使用者身份的證明。</p> <p>OIDC 除了 ID Token 之外，還可以回傳一個標準的使用者存取 token ，既可以代表使用者行動，也可以知道使用者是誰。</p> <p>OIDC 的主要注意事項是，它不支援回傳應用存取 token ，這意味著對於伺服器到伺服器的通訊，OAuth 是你唯一的選擇。儘管如此，我們還是建議在所有其他情況下儘可能使用 OIDC。</p> <h3 id=flows>Flows</h3> <p>對於 OAuth 和 OIDC 來說，它們都支援兩種不同的 flow ，或者說是獲取 token 的方法。它們是「授權碼（Authorization Code）flow」和「隱式（Implicit Code）flow」。</p> <p>這兩種 flow 在幾個關鍵方面有所不同。「授權碼 flow」應該用於有伺服器進行呼叫以獲取 token，並使用該 token 存取受保護的 API 端點的情況。有額外的 handshakes，提供必要的資訊，這意味著使用者永遠不會獲得他們的實際存取 token （除非你把它傳送到前端），使其更加安全。此外，這個 flow 還回傳一個「重新整理 token」 ，這意味著你的使用者在未來不必重新授權你的應用程式。這些「重新整理 token」被你的應用程式用來給使用者一個新的存取 token ，並有一個新的到期日期。</p> <p>「隱式碼 flow」是在客戶端（使用者代理）進行呼叫時使用的。這在使用 React 或 Vue 等框架的單頁應用（SPA）中最為常見。使用者進行身份驗證，瀏覽器在本地獲取並儲存 token ，以代表使用者進行額外的呼叫，或者說 SPA 沒有後端儲存使用者資料。雖然 SPA 架構涉及到一個儲存程式碼的 Web 服務，但這個服務永遠不會獲得使用者的存取 token（除非客戶端將其傳送到後端）。這個 flow 不會回傳「重新整理 token」，所以你需要使用者在 token 過期時重新授權應用。</p> <p>最後，還有一個「客戶端憑證 flow」，它允許你獲取「應用存取 token」。這個 flow 只有透過 OAuth 協議才能使用，也是獲取「應用存取 token」的唯一途徑。如上所述，這些 token 由於缺乏使用者原則，無法使用存取給定使用者受保護資料的端點（例如 GET /users 端點中的使用者電子郵件），並且僅用於伺服器到伺服器的呼叫。該 flow 不回傳「重新整理 token」。</p> <h4 id=授權碼-flow>授權碼 flow</h4> <p>如上所述，與其他 flow 相比，「授權碼 flow」需要一些額外的呼叫，但是由於在授權過程中不需要向瀏覽器傳輸存取 token ，因此最終的應用更加安全。</p> <p>授權碼的 flow 是</p> <ol> <li>你的應用程式將使用者重定向到 Twitch 登入端點</li> <li>使用者登入並授權給應用程式所要求的作用域</li> <li>一旦成功授權，Twitch 就會重定向回您的應用程式，並在 query parameters 中包含一段程式碼。</li> <li>然後，使用一個特殊的端點，用後端伺服器將程式碼交換為您所需的代幣。</li> </ol> <p>這個過程可以讓你安全而謹慎地儲存代幣。雖然比隱式 flow 的步驟更多，但這是 Twitch 的首選方法。</p> <h4 id=隱性碼-flow>隱性碼 flow</h4> <p>另一種面向使用者的 flow 是「隱式 flow」 。這種 flow 專注於儘可能安全地傳輸存取 token ，然而無論如何，存取 token 都會暴露在終端使用者面前。正因為如此，隱式流不支援重新整理 token ，需要使用者每次重新認證才能獲得有效的使用者 token 。</p> <p>這種方式是透過：</p> <ol> <li>使用者會被重定向到 Twitch 登入（使用彈窗或瀏覽器重定向）。</li> <li>然後，使用者授權應用程式</li> <li>然後，使用者會被 Twitch 用 URL 片段中的 token 重定向到重定向 URI（於 Twitch 開發後台設置）。</li> <li>該 URL 看起來像：<code>https://yoururlhere/index.html#access_token=token...</code></li> </ol> <p>這種情況下的 token 不在 request query 中，因為 request query 會被傳送到後端伺服器（以及中間可能出現的任何其他伺服器）。相反，它使用的是 URL 片段，它對後端伺服器不可見，因此更加安全。URL 片段可以透過客戶端的 JavaScript 存取，允許你從 URL 中提取出來，並儲存起來以備後用。</p> <h4 id=客戶證書>客戶證書</h4> <p>最後，「客戶端憑證 flow」的目的是當你需要從「伺服器到伺服器」進行呼叫時。這個 token 不能新增任何額外的作用域，因為沒有一個使用者來繫結這個 token ；相反，這些 token 是為了不特定於任何使用者的後端任務。它可能是涉及應用級分析或需要更高速率限制的任務。</p> <p>正如表格中所指出的，這個 flow 只能使用 OAuth，而不是 OIDC。因此，在選擇這個 flow 時要記住這一點。</p> <p>flow 相當簡單，後臺伺服器向 Twitch 發出請求，要求獲得一個 token ，並得到一個回應。回應格式與授權碼回應相同，因此您能夠以同樣的方式重新整理 token 。</p> <p>但與其他 flow 不同的是，由於這只生成一個應用存取 token ，所以不能將其分配給使用者，因此您不能為這個 token 分配作用域。使用這種型別的 token 通常用於提高呼叫的速率限制，以確保你不會發出未經認證的請求。</p> <h3 id=總結>總結</h3> <p>確定使用什麼技術讓使用者授權你的應用，是你早期要做的一個相當重要的決定。由於可用的選項數量眾多，在剛開始專案時可能會讓人不知所措。然而，簡單地說，對於大多數用例，如果您可以使用 OIDC，您就應該這樣做。鑑於 OIDC 是建立在 OAuth 之上的，對於終端使用者來說，授權 flow 保持不變，你獲得了額外的功能，同時也保留了 OAuth 的所有易用性，而不需要更多的額外複雜性。</p> </details> <h2 id=twitch-oidc-認證回應>Twitch OIDC 認證回應</h2> <ul> <li>Twitch API 文件：<a href=https://dev.twitch.tv/docs/authentication target=_blank rel=nofollow>Authentication | Twitch Developers</a></li> <li>註冊 Twitch APP：<a href=https://dev.twitch.tv/console/apps target=_blank rel=nofollow>Twitch Developers</a></li> <li><a href=https://pjchender.blogspot.com/2018/08/js-javascript-url-parameters.html target=_blank rel=nofollow>[JS] 使用 JavaScript 解析網址與處理網址中的參數（URL Parameters） ~ PJCHENder&lt;br>那些沒告訴你的小細節</a></li> </ul> <h3 id=驗證>驗證</h3> <p><code>GET https://id.twitch.tv/oauth2/authorize?client_id=</code>your client ID<code>&redirect_uri=</code>your registered redirect URI<code>&response_type=</code>type<code>&scope=</code>space-separated list of scopes<code>&claims=</code>JSON object specifying requested claims</p> <h4 id=成功>成功</h4> <p>登入並驗證成功後，會導向回註冊的網址，以及附帶相關參數至網址後方</p> <p><code>https://</code>registered_uri<code>#access_token=</code>access_token<code>&id_token=</code>id_token<code>&scope=openid+user_read&token_type=bearer</code></p> <ol> <li><code>access_token</code></li> <li><code>id_token</code></li> <li><code>scope</code></li> <li><code>token_type</code></li> </ol> <p><code>id_token</code> decoded:</p> <ol> <li><code>at_hash</code></li> <li><code>aud</code>: Audience: client ID of the application requesting a user's authorization.</li> <li><code>azp</code>: Authorized party: client ID of the application which is being authorized. Currently the same as aud.</li> <li><code>exp</code>: Expiration time of the token. This is in UNIX/Epoch format.</li> <li><code>iat</code>: Time when the token was issued. This is in UNIX/Epoch format.</li> <li><code>iss</code>: Issuer of the token.</li> <li><code>preferred_username</code>: Display name of the authorizing user.</li> <li><code>sub</code>: User ID of the authorizing user.</li> </ol> <h4 id=失敗>失敗</h4> <p>如果驗證不過，或有其它地方設定錯誤，也會導向回註冊的網址，以及附帶相關參數至網址後方</p> <p>例如：<code>https://</code>registered_uri<code>?error=redirect_mismatch&error_description=Parameter+redirect_uri+does+not+match+registered+URI</code></p> <ol> <li><code>error</code></li> <li><code>error_description</code></li> </ol> <h3 id=取得使用者帳號>取得使用者帳號</h3> <p>驗證成功後，就可使用取得的 <code>access_token</code> 進行相關資料存取 <br><code>access_token</code> 需輸入於 Header 的 <code>Authorization: Bearer</code> 後方</p> <pre class=language-bash><code class=language-bash>curl  -H 'Client-ID: uo6dggojyb8d6soh92zknwmi5ej1q2' \
-H 'Authorization: Bearer cfabdegwdoklmawdzdo98xt2fo512y' \
-X GET 'https://api.twitch.tv/helix/users?id=44322889'</code></pre> </article> <div class="back-to-top hidden svelte-142cfra" style=right:2em>Back to top </div> </div></main> <footer class=svelte-1nz5bf0><a href=https://creativecommons.org/licenses/by-sa/4.0/ target=_blank rel="noreferrer noopener nofollow">CC BY-SA 4.0.</a> <div class="svelte-1nz5bf0 right">Made with <span class="svelte-1nz5bf0 heart">❤️</span> and <a href=https://github.com/Charca/sapper-blog-template target=_blank ref="noreferrer noopener nofollow">Sapper</a></div> <div class="svelte-1nz5bf0 clearfix"></div> </footer> <a href="https://www.youtube.com/watch?v=AzFJUrKO8U0" target=_blank rel="noreferrer noopener"><img alt=easter_egg src=_c_choju23_0036_s512_choju23_0036_11.png class="easter-egg svelte-72qmgd"> </a> </div></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,{post:{title:"Twitch API Authentication",slug:"twitch-api",html:"\u003Cp\u003E前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容\u003C\u002Fp\u003E\n\u003Csummary\u003E\n\n\u003Ch2 id=\"官方文章：理解哪種協議與流程適合你\"\u003E官方文章：\u003Ca target=\"_blank\" rel=\"nofollow\" href=\"https:\u002F\u002Fblog.twitch.tv\u002Fzh-tw\u002F2019\u002F11\u002F06\u002Ftwitch-authentication-understanding-which-protocol-and-flow-is-right-for-you\u002F\"\u003E理解哪種協議與流程適合你\u003C\u002Fa\u003E\u003C\u002Fh2\u003E\n\u003C\u002Fsummary\u003E\n\u003Cdetails\u003E\n\n\u003Cp\u003E在首次使用 Twitch 開發新的整合或擴充套件時，最常見的障礙之一是確定最適合您需求的驗證方法。這個決定可能會讓人感到困惑，特別是當你是對 REST API 進行身份驗證的新手時，但本指南將涵蓋如何就協議、必要的 token 型別以及使用協議的適當方式做出明智的決定。\u003C\u002Fp\u003E\n\u003Cp\u003ETwitch 提供了兩種協議，即 OAuth 和 OIDC，以使用您選擇的 flow 來連線和獲取 token 。flow 只是指您的應用程式與 Twitch 進行互動以交換 token 的方式，以及回傳 token 的方式。\u003C\u002Fp\u003E\n\u003Cp\u003E此外，在選擇兩種協議的同時，您還需要圍繞您所需的 token 型別做出重要決定；有三種不同的 token 可供選擇，每種 token 都有不同的用途。\u003C\u002Fp\u003E\n\u003Cp\u003E這些決定可能會根據一些因素而變化，例如正在構建的整合型別，您的應用程式如何架構，以及您使用認證協議的經驗水平。\u003C\u002Fp\u003E\n\u003Cp\u003E簡而言之，有一個簡單的圖表，顯示了不同型別的 token 和基礎設施，以幫助您的決策過程。請注意，這並不是絕對的，您的情況可能會有所不同，您應該選擇最適合您需求的選項。\u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E\u003C\u002Fth\u003E\n\u003Cth\u003E擁有後端\u003C\u002Fth\u003E\n\u003Cth\u003E沒有後端／SPA\u003C\u002Fth\u003E\n\u003Cth\u003E伺服器對伺服器（無前端）\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003EID Token\u003C\u002Ftd\u003E\n\u003Ctd\u003EOIDC 授權碼\u003C\u002Ftd\u003E\n\u003Ctd\u003EOIDC 隱式碼\u003C\u002Ftd\u003E\n\u003Ctd\u003E-\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EUser Access Token\u003C\u002Ftd\u003E\n\u003Ctd\u003EOAuth／OIDC 授權碼\u003C\u002Ftd\u003E\n\u003Ctd\u003EOAuth／OIDC 隱式碼\u003C\u002Ftd\u003E\n\u003Ctd\u003E-\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EApp Access Token\u003C\u002Ftd\u003E\n\u003Ctd\u003EOAuth 客戶證書（於後端處理）\u003C\u002Ftd\u003E\n\u003Ctd\u003E-\u003C\u002Ftd\u003E\n\u003Ctd\u003EOAuth 客戶證書\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Ch3 id=\"協議\"\u003E協議\u003C\u002Fh3\u003E\n\u003Cp\u003E如前所述，在應用中認證使用者時有兩種協議可供選擇：OAuth 2.0 和 OIDC。這兩個協議在功能上非常相似，因為 OIDC 是建立在 OAuth 2.0 規範之上的，但也有理由選擇一個而不是另一個。\u003C\u002Fp\u003E\n\u003Ch4 id=\"oauth-20\"\u003EOAuth 2.0\u003C\u002Fh4\u003E\n\u003Cp\u003E我們要介紹的第一個協議是 OAuth 2.0（以下簡稱 OAuth），它是使用 Twitch 平臺授權的最常見方式之一。OAuth 在許多組織中被廣泛採用，它本身就傾向於為幾乎所有的程式語言提供大量可供公眾使用的庫，這意味著在你的應用程式中構建授權是快速和簡單的，只需要很少的定製工作。OAuth 可以提供「使用者存取 token」（User Access Token，通常簡稱為「存取 token」／access token）或「應用程式存取 token」（App Access Token）。「使用者存取 token」允許您的應用程式代表經過認證的使用者，在給定的一組範圍（許可權）內執行操作。另一方面，「應用程式存取 token」僅用於伺服器對伺服器的呼叫，不提供對一些受保護的 API 端點的存取。\u003C\u002Fp\u003E\n\u003Cp\u003E「使用者存取 token」和「應用存取 token」用於針對 Twitch 的 API 進行認證呼叫。\u003C\u002Fp\u003E\n\u003Cp\u003E然而，OAuth 的一個主要問題是，它不是一個認證協議。OAuth 本身並不告訴使用者是誰，而是提供了一組委託許可權，允許透過提供的存取 token 存取受保護的資源。這授權 token 存取材料，但並不對使用者進行身份驗證。\u003C\u002Fp\u003E\n\u003Cp\u003E你可以透過 Twitch API 的 Get User 端點來獲取授權 token 的使用者的詳細資訊，但是僅僅為了獲取使用者身份而呼叫這個端點是對 OAuth 的濫用，因為它只會告訴你 token 的所有者，但不會告訴你他們已經認證進入你的應用。\u003C\u002Fp\u003E\n\u003Cp\u003E這裡的區別主要涉及安全原則。 token 不是使用者認證的證明，就像前門鑰匙不是房屋所有權的證明一樣。 token 只能證明使用者已經授權您的應用程式代表他們行事，這也是我們建議使用下面描述的第二個協議的主要原因之一。\u003C\u002Fp\u003E\n\u003Ch4 id=\"openid-連線\"\u003EOpenID 連線\u003C\u002Fh4\u003E\n\u003Cp\u003EOpenID Connect（OIDC）是建立在 OAuth 之上的，它將 OAuth 規範中的一些東西標準化，讓人們可以選擇。此外，OIDC 除了提供授權之外，還提供了認證。由於 OIDC 是在 OAuth 的基礎上分層的，所以如果你已經熟悉 OAuth，很多東西都是一樣的，因此很容易學習。\u003C\u002Fp\u003E\n\u003Cp\u003E與 OIDC 的主要區別之一是它可以回傳一個「ID Token」，這是一個 JSON Web Token (JWT)，其中包含了認證使用者的資訊。這個 token 可以透過索賠包含使用者的基本資訊，也可以包含使用者的詳細資訊。索賠可以包括（但不限於）使用者名稱、電子郵件和個人資料圖片。這些資訊無需額外的 API 呼叫即可獲得，並為這些資訊提供了快速資源。這可以驗證使用者的身份，以確保使用者是存取材料的人。\u003C\u002Fp\u003E\n\u003Cp\u003E一個 JWT 的範例：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EeyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifQ.eyJhdWQiOiJhOGF2NHo3MGY1M2QyMnNwZXBlemJkaWx5Y29yaHQiLCJleHAiOjE1NTk2NzY2NDEsImlhdCI6MTU1OTY3NTc0MSwiaXNzIjoiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyIiwic3ViIjoiNDQ2MzU1OTYiLCJwaWN0dXJlIjoiaHR0cHM6Ly9zdGF0aWMtY2RuLmp0dm53Lm5ldC9qdHZfdXNlcl9waWN0dXJlcy8zNzVlZTZmZC04ZGNkLTQ3ZjEtOTNkYi04MTY2NzgyODhlMTMtcHJvZmlsZV9pbWFnZS0xNTB4MTUwLnBuZyIsInByZWZlcnJlZF91c2VybmFtZSI6IkNvbmNyZXRlRW50cmVlIn0.xz44-jsojGL188TkO5TqqEVusAnCEFWUXdkX5awV-0m5FFTHqEfZOTHxUMV3UCfmDGaz76g0kVm0NErYT4GRZjYmeahIYOWFQhQ0tdf31JGflrh3IXCjHAEnAcVHiHLQirrK9gC2zuqIbW3383lLmiFbakG1KdginYScWjUTHF3RPyeQsWjQI8iscRr_i9ogmRnHfq1bj3sS0DBQiJ1OTmUwBhXFXI9dWZGskvCXDAQ2m06ulB7lYgkl_yaqYaXOfnhcrvIrfcwSTqByPJP3bpUwFUsDpePhShFuogxEpzF1hWSXb1x819uldtF0PQfBhAtIs28f5DrSDUWNb5IChQ\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E經過解碼（使用 \u003Ca target=\"_blank\" rel=\"nofollow\" href=\"https:\u002F\u002Fjwt.io\u002F\"\u003Ehttps:\u002F\u002Fjwt.io\u002F\u003C\u002Fa\u003E）後會變為\u003C\u002Fp\u003E\n\u003Cpre class=\"language-json\"\u003E\u003Ccode class=\"language-json\"\u003E{\n  \"aud\": \"a8av4z70f53d22spepezbdilycorht\",\n  \"exp\": 1559676641,\n  \"iat\": 1559675741,\n  \"iss\": \"https:\u002F\u002Fid.twitch.tv\u002Foauth2\",\n  \"sub\": \"44635596\",\n  \"picture\": \"https:\u002F\u002Fstatic-cdn.jtvnw.net\u002Fjtv_user_pictures\u002F375ee6fd-8dcd-47f1-93db-816678288e13-profile_image-150x150.png\",\n  \"preferred_username\": \"ConcreteEntree\"\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\u003Cp\u003E這些資訊也可以用於展示目的，所以，例如，React 應用程式可以將 JWT 儲存在狀態中，並引用使用者名稱作為頁面頭部的一部分，而不是將其儲存在資料庫的某個地方，需要在登入時獲取；該資料也會隨著每次 token 的重新整理而更新，這意味著資料是最新的。\u003C\u002Fp\u003E\n\u003Cp\u003E需要注意的是，ID Token 並不是用來進行 API 請求的，它只是認證以及使用者身份的證明。\u003C\u002Fp\u003E\n\u003Cp\u003EOIDC 除了 ID Token 之外，還可以回傳一個標準的使用者存取 token ，既可以代表使用者行動，也可以知道使用者是誰。\u003C\u002Fp\u003E\n\u003Cp\u003EOIDC 的主要注意事項是，它不支援回傳應用存取 token ，這意味著對於伺服器到伺服器的通訊，OAuth 是你唯一的選擇。儘管如此，我們還是建議在所有其他情況下儘可能使用 OIDC。\u003C\u002Fp\u003E\n\u003Ch3 id=\"flows\"\u003EFlows\u003C\u002Fh3\u003E\n\u003Cp\u003E對於 OAuth 和 OIDC 來說，它們都支援兩種不同的 flow ，或者說是獲取 token 的方法。它們是「授權碼（Authorization Code）flow」和「隱式（Implicit Code）flow」。\u003C\u002Fp\u003E\n\u003Cp\u003E這兩種 flow 在幾個關鍵方面有所不同。「授權碼 flow」應該用於有伺服器進行呼叫以獲取 token，並使用該 token 存取受保護的 API 端點的情況。有額外的 handshakes，提供必要的資訊，這意味著使用者永遠不會獲得他們的實際存取 token （除非你把它傳送到前端），使其更加安全。此外，這個 flow 還回傳一個「重新整理 token」 ，這意味著你的使用者在未來不必重新授權你的應用程式。這些「重新整理 token」被你的應用程式用來給使用者一個新的存取 token ，並有一個新的到期日期。\u003C\u002Fp\u003E\n\u003Cp\u003E「隱式碼 flow」是在客戶端（使用者代理）進行呼叫時使用的。這在使用 React 或 Vue 等框架的單頁應用（SPA）中最為常見。使用者進行身份驗證，瀏覽器在本地獲取並儲存 token ，以代表使用者進行額外的呼叫，或者說 SPA 沒有後端儲存使用者資料。雖然 SPA 架構涉及到一個儲存程式碼的 Web 服務，但這個服務永遠不會獲得使用者的存取 token（除非客戶端將其傳送到後端）。這個 flow 不會回傳「重新整理 token」，所以你需要使用者在 token 過期時重新授權應用。\u003C\u002Fp\u003E\n\u003Cp\u003E最後，還有一個「客戶端憑證 flow」，它允許你獲取「應用存取 token」。這個 flow 只有透過 OAuth 協議才能使用，也是獲取「應用存取 token」的唯一途徑。如上所述，這些 token 由於缺乏使用者原則，無法使用存取給定使用者受保護資料的端點（例如 GET \u002Fusers 端點中的使用者電子郵件），並且僅用於伺服器到伺服器的呼叫。該 flow 不回傳「重新整理 token」。\u003C\u002Fp\u003E\n\u003Ch4 id=\"授權碼-flow\"\u003E授權碼 flow\u003C\u002Fh4\u003E\n\u003Cp\u003E如上所述，與其他 flow 相比，「授權碼 flow」需要一些額外的呼叫，但是由於在授權過程中不需要向瀏覽器傳輸存取 token ，因此最終的應用更加安全。\u003C\u002Fp\u003E\n\u003Cp\u003E授權碼的 flow 是\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E你的應用程式將使用者重定向到 Twitch 登入端點\u003C\u002Fli\u003E\n\u003Cli\u003E使用者登入並授權給應用程式所要求的作用域\u003C\u002Fli\u003E\n\u003Cli\u003E一旦成功授權，Twitch 就會重定向回您的應用程式，並在 query parameters 中包含一段程式碼。\u003C\u002Fli\u003E\n\u003Cli\u003E然後，使用一個特殊的端點，用後端伺服器將程式碼交換為您所需的代幣。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E這個過程可以讓你安全而謹慎地儲存代幣。雖然比隱式 flow 的步驟更多，但這是 Twitch 的首選方法。\u003C\u002Fp\u003E\n\u003Ch4 id=\"隱性碼-flow\"\u003E隱性碼 flow\u003C\u002Fh4\u003E\n\u003Cp\u003E另一種面向使用者的 flow 是「隱式 flow」 。這種 flow 專注於儘可能安全地傳輸存取 token ，然而無論如何，存取 token 都會暴露在終端使用者面前。正因為如此，隱式流不支援重新整理 token ，需要使用者每次重新認證才能獲得有效的使用者 token 。\u003C\u002Fp\u003E\n\u003Cp\u003E這種方式是透過：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E使用者會被重定向到 Twitch 登入（使用彈窗或瀏覽器重定向）。\u003C\u002Fli\u003E\n\u003Cli\u003E然後，使用者授權應用程式\u003C\u002Fli\u003E\n\u003Cli\u003E然後，使用者會被 Twitch 用 URL 片段中的 token 重定向到重定向 URI（於 Twitch 開發後台設置）。\u003C\u002Fli\u003E\n\u003Cli\u003E該 URL 看起來像：\u003Ccode\u003Ehttps:\u002F\u002Fyoururlhere\u002Findex.html#access_token=token...\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E這種情況下的 token 不在 request query 中，因為 request query 會被傳送到後端伺服器（以及中間可能出現的任何其他伺服器）。相反，它使用的是 URL 片段，它對後端伺服器不可見，因此更加安全。URL 片段可以透過客戶端的 JavaScript 存取，允許你從 URL 中提取出來，並儲存起來以備後用。\u003C\u002Fp\u003E\n\u003Ch4 id=\"客戶證書\"\u003E客戶證書\u003C\u002Fh4\u003E\n\u003Cp\u003E最後，「客戶端憑證 flow」的目的是當你需要從「伺服器到伺服器」進行呼叫時。這個 token 不能新增任何額外的作用域，因為沒有一個使用者來繫結這個 token ；相反，這些 token 是為了不特定於任何使用者的後端任務。它可能是涉及應用級分析或需要更高速率限制的任務。\u003C\u002Fp\u003E\n\u003Cp\u003E正如表格中所指出的，這個 flow 只能使用 OAuth，而不是 OIDC。因此，在選擇這個 flow 時要記住這一點。\u003C\u002Fp\u003E\n\u003Cp\u003Eflow 相當簡單，後臺伺服器向 Twitch 發出請求，要求獲得一個 token ，並得到一個回應。回應格式與授權碼回應相同，因此您能夠以同樣的方式重新整理 token 。\u003C\u002Fp\u003E\n\u003Cp\u003E但與其他 flow 不同的是，由於這只生成一個應用存取 token ，所以不能將其分配給使用者，因此您不能為這個 token 分配作用域。使用這種型別的 token 通常用於提高呼叫的速率限制，以確保你不會發出未經認證的請求。\u003C\u002Fp\u003E\n\u003Ch3 id=\"總結\"\u003E總結\u003C\u002Fh3\u003E\n\u003Cp\u003E確定使用什麼技術讓使用者授權你的應用，是你早期要做的一個相當重要的決定。由於可用的選項數量眾多，在剛開始專案時可能會讓人不知所措。然而，簡單地說，對於大多數用例，如果您可以使用 OIDC，您就應該這樣做。鑑於 OIDC 是建立在 OAuth 之上的，對於終端使用者來說，授權 flow 保持不變，你獲得了額外的功能，同時也保留了 OAuth 的所有易用性，而不需要更多的額外複雜性。\u003C\u002Fp\u003E\n\u003C\u002Fdetails\u003E\n\n\u003Ch2 id=\"twitch-oidc-認證回應\"\u003ETwitch OIDC 認證回應\u003C\u002Fh2\u003E\n\u003Cul\u003E\n\u003Cli\u003ETwitch API 文件：\u003Ca target=\"_blank\" rel=\"nofollow\" href=\"https:\u002F\u002Fdev.twitch.tv\u002Fdocs\u002Fauthentication\"\u003EAuthentication | Twitch Developers\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E註冊 Twitch APP：\u003Ca target=\"_blank\" rel=\"nofollow\" href=\"https:\u002F\u002Fdev.twitch.tv\u002Fconsole\u002Fapps\"\u003ETwitch Developers\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ca target=\"_blank\" rel=\"nofollow\" href=\"https:\u002F\u002Fpjchender.blogspot.com\u002F2018\u002F08\u002Fjs-javascript-url-parameters.html\"\u003E[JS] 使用 JavaScript 解析網址與處理網址中的參數（URL Parameters） ~ PJCHENder&lt;br&gt;那些沒告訴你的小細節\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"驗證\"\u003E驗證\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Ccode\u003EGET https:\u002F\u002Fid.twitch.tv\u002Foauth2\u002Fauthorize?client_id=\u003C\u002Fcode\u003Eyour client ID\u003Ccode\u003E&amp;redirect_uri=\u003C\u002Fcode\u003Eyour registered redirect URI\u003Ccode\u003E&amp;response_type=\u003C\u002Fcode\u003Etype\u003Ccode\u003E&amp;scope=\u003C\u002Fcode\u003Espace-separated list of scopes\u003Ccode\u003E&amp;claims=\u003C\u002Fcode\u003EJSON object specifying requested claims\u003C\u002Fp\u003E\n\u003Ch4 id=\"成功\"\u003E成功\u003C\u002Fh4\u003E\n\u003Cp\u003E登入並驗證成功後，會導向回註冊的網址，以及附帶相關參數至網址後方\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003Ehttps:\u002F\u002F\u003C\u002Fcode\u003Eregistered_uri\u003Ccode\u003E#access_token=\u003C\u002Fcode\u003Eaccess_token\u003Ccode\u003E&amp;id_token=\u003C\u002Fcode\u003Eid_token\u003Ccode\u003E&amp;scope=openid+user_read&amp;token_type=bearer\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Eaccess_token\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eid_token\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Escope\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Etoken_type\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Ccode\u003Eid_token\u003C\u002Fcode\u003E decoded:\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Eat_hash\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eaud\u003C\u002Fcode\u003E: Audience: client ID of the application requesting a user&#39;s authorization.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eazp\u003C\u002Fcode\u003E: Authorized party: client ID of the application which is being authorized. Currently the same as aud.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eexp\u003C\u002Fcode\u003E: Expiration time of the token. This is in UNIX\u002FEpoch format.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eiat\u003C\u002Fcode\u003E: Time when the token was issued. This is in UNIX\u002FEpoch format.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eiss\u003C\u002Fcode\u003E: Issuer of the token.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Epreferred_username\u003C\u002Fcode\u003E: Display name of the authorizing user.\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Esub\u003C\u002Fcode\u003E: User ID of the authorizing user.\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch4 id=\"失敗\"\u003E失敗\u003C\u002Fh4\u003E\n\u003Cp\u003E如果驗證不過，或有其它地方設定錯誤，也會導向回註冊的網址，以及附帶相關參數至網址後方\u003C\u002Fp\u003E\n\u003Cp\u003E例如：\u003Ccode\u003Ehttps:\u002F\u002F\u003C\u002Fcode\u003Eregistered_uri\u003Ccode\u003E?error=redirect_mismatch&amp;error_description=Parameter+redirect_uri+does+not+match+registered+URI\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Eerror\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Ccode\u003Eerror_description\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"取得使用者帳號\"\u003E取得使用者帳號\u003C\u002Fh3\u003E\n\u003Cp\u003E驗證成功後，就可使用取得的 \u003Ccode\u003Eaccess_token\u003C\u002Fcode\u003E 進行相關資料存取\n\u003Cbr\u003E\u003Ccode\u003Eaccess_token\u003C\u002Fcode\u003E 需輸入於 Header 的 \u003Ccode\u003EAuthorization: Bearer\u003C\u002Fcode\u003E 後方\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003Ecurl  -H 'Client-ID: uo6dggojyb8d6soh92zknwmi5ej1q2' \\\n-H 'Authorization: Bearer cfabdegwdoklmawdzdo98xt2fo512y' \\\n-X GET 'https:\u002F\u002Fapi.twitch.tv\u002Fhelix\u002Fusers?id=44322889'\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E",date:"2020-11-08T23:50:09.000Z",excerpt:"前陣子剛好有機會，寫了個用到 Twitch OAuth 登入認證的網站，順手記錄用到的內容",printDate:"November 8, 2020",printReadingTime:"4 min read",tags:[],image:"https:\u002F\u002Ff6bfb5.github.io\u002Fpreview\u002Ftwitch-api.png"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');var s=document.createElement("script");try{new Function("if(0)import('')")();s.src="/client/client.fe24f1bc.js";s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main","/client/client.fe24f1bc.js")}document.head.appendChild(s)</script> 